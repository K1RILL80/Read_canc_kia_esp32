#include <Arduino.h>
#include <ESP32-TWAI-CAN.hpp>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>

// --- ЛОГОТИП (118x62 пикселя) ---
const unsigned char PROGMEM kia_logo_118x62[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
  0xff, 0xfe, 0x01, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0,
  0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00,
  0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
  0xfc, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
  0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80,
  0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00,
  0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00,
  0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0xfe,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0xfc, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x01, 0xf8, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x03, 0xf0, 0x00, 0x80, 0x00,
  0x00, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x07, 0xf8, 0x3f, 0x00, 0x07, 0xf0, 0x03, 0x80, 0x00, 0x00,
  0xff, 0x7f, 0x80, 0x00, 0x00, 0x1f, 0xf8, 0x3f, 0x80, 0x07, 0xe0, 0x0f, 0x80, 0x00, 0x03, 0xfc,
  0x7f, 0x80, 0x00, 0x00, 0x3f, 0xf8, 0x1f, 0x80, 0x0f, 0xc0, 0x1f, 0x80, 0x00, 0x07, 0xf8, 0x7f,
  0x80, 0x00, 0x00, 0xff, 0xf8, 0x0f, 0xc0, 0x0f, 0xc0, 0x7f, 0x80, 0x00, 0x1f, 0xe0, 0x7f, 0x80,
  0x00, 0x01, 0xff, 0xf8, 0x0f, 0xc0, 0x0f, 0xc0, 0x7f, 0x80, 0x00, 0x7f, 0x80, 0x7f, 0x80, 0x00,
  0x07, 0xff, 0xf8, 0x0f, 0xc0, 0x1f, 0x80, 0x7f, 0x80, 0x00, 0xff, 0x00, 0x7f, 0x80, 0x00, 0x0f,
  0xe7, 0xf8, 0x07, 0xe0, 0x1f, 0x80, 0x7f, 0x80, 0x03, 0xfc, 0x00, 0x7f, 0x80, 0x00, 0x3f, 0xc7,
  0xf8, 0x07, 0xe0, 0x1f, 0x80, 0xff, 0x80, 0x07, 0xf0, 0x00, 0x7f, 0x80, 0x00, 0x7f, 0x07, 0xf8,
  0x07, 0xe0, 0x1f, 0x80, 0xff, 0x80, 0x1f, 0xf0, 0x00, 0x7f, 0x80, 0x01, 0xfe, 0x07, 0xf8, 0x07,
  0xe0, 0x1f, 0x80, 0xff, 0x80, 0x7f, 0xf0, 0x00, 0x7f, 0x80, 0x03, 0xf8, 0x07, 0xf8, 0x07, 0xe0,
  0x1f, 0x80, 0xff, 0x80, 0xff, 0xf8, 0x00, 0x7f, 0x80, 0x0f, 0xf0, 0x07, 0xf8, 0x07, 0xe0, 0x1f,
  0x80, 0x7f, 0x83, 0xff, 0xfc, 0x00, 0x7f, 0x80, 0x1f, 0xc0, 0x07, 0xf8, 0x07, 0xe0, 0x1f, 0x80,
  0x7f, 0x8f, 0xf3, 0xfe, 0x00, 0x7f, 0x80, 0x7f, 0x80, 0x07, 0xf8, 0x07, 0xe0, 0x0f, 0xc0, 0xff,
  0x9f, 0xe1, 0xff, 0x00, 0x7f, 0x80, 0xfe, 0x00, 0x07, 0xf8, 0x0f, 0xc0, 0x0f, 0xc0, 0xff, 0xff,
  0x80, 0xff, 0x80, 0x7f, 0x83, 0xfc, 0x00, 0x07, 0xf0, 0x0f, 0xc0, 0x07, 0xe0, 0xff, 0xfe, 0x00,
  0x7f, 0xc0, 0x7f, 0xc7, 0xf0, 0x00, 0x07, 0xc0, 0x1f, 0x80, 0x07, 0xe0, 0x7f, 0xfc, 0x00, 0x3f,
  0xe0, 0x7f, 0xdf, 0xe0, 0x00, 0x07, 0x80, 0x1f, 0x80, 0x03, 0xf0, 0x7f, 0xf0, 0x00, 0x1f, 0xf0,
  0x7f, 0xff, 0x80, 0x00, 0x06, 0x00, 0x3f, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x03, 0xf8, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x07, 0xf0, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
  0xe0, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80,
  0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00,
  0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00,
  0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00,
  0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80,
  0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
  0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff,
  0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00
};

// --- НАСТРОЙКИ ---
const float R1 = 46470.0;
const float R2 = 9930.0;
const float V_REF = 3.464;

#define SDA_PIN 8
#define SCL_PIN 9
#define CAN_RX_PIN GPIO_NUM_2
#define CAN_TX_PIN GPIO_NUM_1
#define VOLTAGE_PIN 4
#define BUTTON_PIN 5

Adafruit_SH1106G display = Adafruit_SH1106G(128, 64, &Wire, -1);

char voltage_str[10] = "-----";
const unsigned long timeout_duration = 10000;
bool canInitialized = false;

enum ParamID {
  P_AT, // температура АКПП
  P_GEAR, // Объединенный параметр  P_GSelD и P_CurG
  P_OIL, // температура масла ДВС
  //P_GSelD, //0 = P; 7 = R; 6 = N; 5 = D; 8  = Manual;
  //P_CurG, // 0 = P, N; 14 = R; 0, 1, 2, 3, 4, 5, 6 = D, Manual;
  P_SOC, // заряд батареи 
  P_IBSV, // напряжение батареи
  P_IBSI, // ток батареи
  P_IBST, // температура батареи
  P_ENG,  // Последний элемент для фиксации в первой строке
  PARAM_COUNT
};

const char* paramNames[PARAM_COUNT] = {
  "AT", 
  "GEAR",
  "OIL", 
  //"Seltr", 
  "SOC", 
  "IBS", 
  "IBS", 
  "IBS", 
  "ENG"
};

// --- Единицы измерения ---
const char* paramUnits[PARAM_COUNT] = {
  "C",    // AT
  "",     // Gear
  "C",    // OIL
  "%",    // SOC
  "V",    // IBSV   
  "A",    // IBSI
  "C",    // IBST
  "C"     // ENG
};


char paramValue[PARAM_COUNT][10];
unsigned long paramLastUpdate[PARAM_COUNT];

uint8_t lastGSelD = 255; // 255 = нет данных
uint8_t lastCurG = 255;


uint8_t currentParam = 0;
const uint8_t scrollCount = PARAM_COUNT - 1;  // Все кроме ENG

void updateParam(uint8_t id, const char* value) {
  if (id < PARAM_COUNT) {
    strncpy(paramValue[id], value, 9);
    paramValue[id][9] = '\0';
    paramLastUpdate[id] = millis();
  }
}

void setup() {
  Serial.begin(115200);
  Wire.begin(SDA_PIN, SCL_PIN);
  pinMode(BUTTON_PIN, INPUT_PULLUP);

  if (display.begin(0x3C, true)) {
    display.setContrast(50);
    display.clearDisplay();
    display.setTextColor(SH110X_WHITE);
    // Координаты для 118x62 на экране 128x64: x=5, y=1
    display.drawBitmap(5, 1, kia_logo_118x62, 118, 62, SH110X_WHITE);
    display.display();
    delay(1000);
  }

  analogReadResolution(12);
  for (int i = 0; i < PARAM_COUNT; i++) {
    strcpy(paramValue[i], "-----");
    paramLastUpdate[i] = 0;
  }

  if (ESP32Can.begin(TWAI_SPEED_500KBPS, CAN_TX_PIN, CAN_RX_PIN, 10, 10)) {
    canInitialized = true;
    display.clearDisplay();
    display.setCursor(10, 35);
    display.println("CAN Init: OK v9");
  } else {
    display.setCursor(10, 35);
    display.println("CAN Init: ERROR");
  }
  display.display();
  delay(1000);
}


void loop() {
  unsigned long currentMillis = millis();
  static unsigned long lastDisplayUpdate = 0;
  bool dataUpdated = false;

  // 1. Кнопка (цикл по scrollCount)
  static unsigned long lastPress = 0;
  if (digitalRead(BUTTON_PIN) == LOW && (currentMillis - lastPress > 250)) {
    lastPress = currentMillis;
    currentParam = (currentParam + 1) % scrollCount;
    dataUpdated = true;
  }

  // 2. Вольтметр
  static unsigned long last_voltage_time = 0;
  if (currentMillis - last_voltage_time >= 1500) {
    last_voltage_time = currentMillis;
    long sum_adc = 0;
    for (int i = 0; i < 64; i++) sum_adc += analogRead(VOLTAGE_PIN);
    float v_val = ((float)sum_adc / 64.0 / 4095.0) * V_REF * ((R1 + R2) / R2);
    dtostrf(v_val, 5, 1, voltage_str);
    dataUpdated = true;
  }

  // 3. CAN Прием
  CanFrame rxFrame;
  if (canInitialized && ESP32Can.readFrame(rxFrame, 0)) {
    char buf[12]; // размер буфера 
    bool gearChanged = false;

    switch (rxFrame.identifier) {
      case 0x111:
        dtostrf((float)rxFrame.data[4] - 40.0, 5, 0, buf);
        updateParam(P_AT, buf);
        lastGSelD = rxFrame.data[1] & 0x0F;
        gearChanged = true;
        dataUpdated = true;
        break;

      case 0x112:
        lastCurG = rxFrame.data[1] & 0x0F;
        gearChanged = true;
        dataUpdated = true;
        break;

      case 0x329:
        dtostrf((float)rxFrame.data[1] * 0.75 - 48.0, 5, 1, buf);
        updateParam(P_ENG, buf);
        dataUpdated = true;
        break;

      case 0x492:
        dtostrf((float)rxFrame.data[4] * 0.75 - 40.0, 5, 1, buf);
        updateParam(P_OIL, buf);
        dataUpdated = true;
        break;

      case 0x549: {
        // Ток заряда/разряда (IBSI)
        uint16_t rawU = rxFrame.data[0] | (rxFrame.data[1] << 8);
        float current = (float)rawU * 0.01 - 327.0;
        dtostrf(current, 5, 1, buf);
        updateParam(P_IBSI, buf);

        // SOC
        dtostrf((float)rxFrame.data[2], 5, 0, buf);
        updateParam(P_SOC, buf);

        // Напряжение (IBSV)
        uint16_t rawV = rxFrame.data[3] | ((rxFrame.data[4] & 0x3F) << 8);
        dtostrf(rawV * 0.001 + 6.0, 5, 1, buf);
        updateParam(P_IBSV, buf);

        // Температура (IBST)
        uint16_t rawT = (rxFrame.data[4] >> 6) | ((rxFrame.data[5] & 0x7F) << 2);
        int16_t signedRawT = (int16_t)rawT;
        if (signedRawT & 0x100) signedRawT -= 0x200; 
        dtostrf(signedRawT * 0.5 - 40.0, 5, 1, buf);
        updateParam(P_IBST, buf);
        
        dataUpdated = true;
        break;
      }
    }

    if (gearChanged) {
      char gearText[10] = "---";
      if (lastGSelD == 0)      strcpy(gearText, " P");
      else if (lastGSelD == 7) strcpy(gearText, " R");
      else if (lastGSelD == 6) strcpy(gearText, " N");
      else if (lastGSelD == 5 || lastGSelD == 8) {
        if (lastCurG >= 1 && lastCurG <= 6) sprintf(gearText, " D%d", lastCurG);
        else if (lastCurG == 14) strcpy(gearText, " R");
        else strcpy(gearText, " D");
      }
      updateParam(P_GEAR, gearText);
    }
  }

  // 4. Таймауты (пересчитываем currentMillis для актуального времени)
  currentMillis = millis();
  for (int i = 0; i < PARAM_COUNT; i++) {
     // Проверяем таймаут только если параметр уже получал данные (paramLastUpdate[i] != 0)
    // и значение не равно "-----" (чтобы не проверять уже устаревшие параметры)
    if (paramLastUpdate[i] != 0 && strcmp(paramValue[i], "-----") != 0) {
      unsigned long timeSinceUpdate = currentMillis - paramLastUpdate[i];
      
      // Проверяем таймаут (для unsigned long переполнение обрабатывается автоматически)
      if (timeSinceUpdate > timeout_duration) {
        strcpy(paramValue[i], "-----");
        dataUpdated = true;
        
        // Дополнительный сброс для Gear, чтобы не "зависли" старые данные селектора
        if (i == P_GEAR) {
          lastGSelD = 255;
          lastCurG = 255;
        }
      }
    }
  }

 
  // 5. Отрисовка (5 Гц)
  if (dataUpdated && (currentMillis - lastDisplayUpdate >= 200)) {
    lastDisplayUpdate = currentMillis;
    display.clearDisplay();

    // Стр 1: ENG
    display.setTextSize(1);
    display.setCursor(0, 5);
    display.print("ENG");
    display.setTextSize(2);
    display.setCursor(35, 0);
    display.print(paramValue[P_ENG]);
    if (strcmp(paramValue[P_ENG], "-----") != 0) {
      display.setTextSize(1);
       display.setCursor(101, 0);
      display.write(167); // Символ градуса
      display.setTextSize(2); 
      display.print("C");
    }
    
     // Стр 2: Прокрутка по кругу
    display.setTextSize(1);
    display.setCursor(0, 25);
    display.print(paramNames[currentParam]);
    display.setTextSize(2);
    display.setCursor(35, 20);
    display.print(paramValue[currentParam]);
    
    // Юниты для Стр 2
    if (strcmp(paramValue[currentParam], "-----") != 0 && strlen(paramUnits[currentParam]) > 0) {
      if (strcmp(paramUnits[currentParam], "C") == 0) {
        display.setTextSize(1); 
        display.setCursor(101, 20); 
        display.write(167);
        display.setTextSize(2); 
        display.print("C");
      } else {
        display.setCursor(107, 20); 
        display.print(paramUnits[currentParam]);
      }
    }
    
  
    // Стр 3: Вольтметр
    display.setTextSize(1);
    display.setCursor(0, 45);
    display.print("BAT");
    display.setTextSize(2);
    display.setCursor(35, 40);
    display.print(voltage_str);
    display.setCursor(107, 40);
    display.print("V");

    display.display();
  }
}
